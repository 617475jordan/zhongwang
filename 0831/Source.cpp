///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.1
/////////////////////////////////////////////////////////////////////////////
#include <halcon_all.h>
#include <opencv_all.h>
#include "halconObjectRecognition.h"

Mat m_matImg, m_matROIImg,m_matTmpImg,m_matDstImg;
VideoCapture capture;
void on_mouse(int event, int x, int y, int flags, void *ustc);//event鼠标事件代号，x,y鼠标坐标，flags拖拽和键盘操作的代号  

int main(int argc, char *argv[])
{
#if defined(_WIN32)
	SetSystem("use_window_thread", "true");
#elif defined(__linux__)
	XInitThreads();
#endif

	halconObjectRecognition halconObjectRecognition;
	halconObjectRecognition.initialize();
	halconObjectRecognition.action();

	system("pause");
	return 0;
}


void on_mouse(int event, int x, int y, int flags, void *ustc)//event鼠标事件代号，x,y鼠标坐标，flags拖拽和键盘操作的代号  
{
	static Point m_pointPreCoordinate = (-1, -1);//初始坐标  
	static Point m_pointCurCoordinate = (-1, -1);//实时坐标  
	char m_charName[16];
	if (event == CV_EVENT_LBUTTONDOWN)//左键按下，读取初始坐标，并在图像上该点处划圆  
	{
		m_matImg.copyTo(m_matTmpImg);//将原始图片复制到img中  
		sprintf(m_charName, "(%d,%d)", x, y);
		m_pointPreCoordinate = Point(x, y);
		putText(m_matTmpImg, m_charName, m_pointPreCoordinate, FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0, 255), 1, 8);//在窗口上显示坐标  
		circle(m_matTmpImg, m_pointPreCoordinate, 2, Scalar(255, 0, 0, 0), CV_FILLED, CV_AA, 0);//划圆  
		imshow("img", m_matTmpImg);
	}
	else if (event == CV_EVENT_MOUSEMOVE && !(flags & CV_EVENT_FLAG_LBUTTON))//左键没有按下的情况下鼠标移动的处理函数  
	{
		m_matTmpImg.copyTo(m_matDstImg);//将img复制到临时图像tmp上，用于显示实时坐标  
		sprintf(m_charName, "(%d,%d)", x, y);
		m_pointCurCoordinate = Point(x, y);
		putText(m_matDstImg, m_charName, m_pointCurCoordinate, FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0, 255));//只是实时显示鼠标移动的坐标  
		imshow("img", m_matDstImg);
	}
	else if (event == CV_EVENT_MOUSEMOVE && (flags & CV_EVENT_FLAG_LBUTTON))//左键按下时，鼠标移动，则在图像上划矩形  
	{
		m_matTmpImg.copyTo(m_matDstImg);
		sprintf(m_charName, "(%d,%d)", x, y);
		m_pointCurCoordinate = Point(x, y);
		putText(m_matTmpImg, m_charName, m_pointCurCoordinate, FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0, 255));
		rectangle(m_matTmpImg, m_pointPreCoordinate, m_pointCurCoordinate, Scalar(0, 255, 0, 0), 1, 8, 0);//在临时图像上实时显示鼠标拖动时形成的矩形  
		imshow("img", m_matTmpImg);
	}
	else if (event == CV_EVENT_LBUTTONUP)//左键松开，将在图像上划矩形  
	{
		m_matImg.copyTo(m_matROIImg);
		sprintf(m_charName, "(%d,%d)", x, y);
		m_pointCurCoordinate = Point(x, y);
		//img.copyTo(tmp);
		//截取矩形包围的图像，并保存到dst中  
		int width = abs(m_pointPreCoordinate.x - m_pointCurCoordinate.x);
		int height = abs(m_pointPreCoordinate.y - m_pointCurCoordinate.y);
		if (width == 0 || height == 0&&width*height<20)
		{
			cout << "Failed to new Image" << endl;
			return;
		}
		putText(m_matROIImg, m_charName, m_pointCurCoordinate, FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0, 255));
		circle(m_matROIImg, m_pointPreCoordinate, 2, Scalar(255, 0, 0, 0), CV_FILLED, CV_AA, 0);
		rectangle(m_matROIImg, m_pointPreCoordinate, m_pointCurCoordinate, Scalar(0, 255, 0, 0), 1, 8, 0);//根据初始点和结束点，将矩形画到img上  
		imshow("img", m_matROIImg);
		/*dst = org(Rect(min(cur_pt.x, pre_pt.x), min(cur_pt.y, pre_pt.y), width, height));
	    namedWindow("dst");
		imshow("dst", dst);
		waitKey(0);*/
	}
}


